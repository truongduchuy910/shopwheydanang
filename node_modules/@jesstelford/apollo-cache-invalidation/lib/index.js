'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.invalidateFields = exports.matchFinder = exports.findMatchingPaths = exports.fieldMatch = exports.ROOT = undefined;

var _traverse = require('traverse');

var _traverse2 = _interopRequireDefault(_traverse);

var _objectPath = require('object-path');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ROOT = exports.ROOT = 'ROOT_QUERY';

/**
 * Test a field name match against a given key.
 *
 * @param {String|RegExp|Function} key The key to look for.
 * @param {String} name The name to compare the key against.
 * @return {Boolean} key/name matches.
 */
var fieldMatch = exports.fieldMatch = function fieldMatch(key, name) {
  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (typeof key === 'string') return key === name;
  if (key instanceof RegExp) return !!name.match(key);
  if (key instanceof Function) return key(name, context);
  return false;
};

/**
 * Checks if a given traversing node is a reference.
 *
 * @param {Object} node Traversing node.
 * @return {Boolean} wheter or not the node is a reference.
 */
var isReference = function isReference() {
  var node = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return node && Object.keys(node).every(function (key) {
    return ['type', 'id', 'generated'].includes(key);
  }) && Object.keys(node).length > 0;
};

/**
 * Find matching paths on a given data object and add new paths
 * to search queue when references are found.
 *
 * @param {Object} data The data object (i.g. apollo cache store).
 * @param {Array[String]]} path Key path array.
 * @param {Function} addPath Method to add paths to queue (used on references).
 * @return {Function} reducer.
 */
var findMatchingPaths = exports.findMatchingPaths = function findMatchingPaths(data, path, addPath) {
  function findMatches(matches) {
    var _this = this;

    if (this.isRoot) return matches;
    if (!fieldMatch(path[this.level - 1], this.key, this)) return this.block(), matches;

    // Add reference path.
    if (isReference(this.node)) {
      addPath([this.node.id].concat(path.slice(this.path.length)));
    }

    // Add array of reference paths.
    if (Array.isArray(this.node) && isReference(this.node[0])) {
      this.node.forEach(function (_ref) {
        var id = _ref.id;
        return addPath([id].concat(path.slice(_this.path.length)));
      });
    }

    // Matched and last.
    if (path.length === this.path.length) matches.push(this.path);

    return matches;
  }

  return (0, _traverse2.default)(data).reduce(findMatches, []);
};

/**
 * Given an array of paths, find matching field paths.
 *
 * @param {Object} data The data object (i.g. apollo cache store).
 * @param {Array[Array[String]]} paths Array of paths of keys.
 * @return {Array} matching field paths.
 */
var matchFinder = exports.matchFinder = function matchFinder(data, paths) {
  var i = 0;
  var result = [];

  var addPath = function addPath(path) {
    return paths.push(path);
  };

  while (paths[i]) {
    result = result.concat(findMatchingPaths(data, paths[i], addPath));
    i++;
  }

  return result;
};

/**
 * Apollo cache invalidator based on paths.
 *
 * @param {Function} generator A function which will be executed with the proxy
 *                             and the query result as as arguments and must return
 *                             an array of invalidating field paths.
 * @return {Function} update Update function such as expected by Apollo option.
 */
var invalidateFields = exports.invalidateFields = function invalidateFields(generator) {
  return function (proxy, result) {
    // This relies on a couple of implementation details of apollo-cache-inmemory,
    // namely that `proxy` will actually be the cache itself and its `data` property
    // will be an instance of the internal class `ObjectCache`.
    // These are not guaranteed by the public API and so invalidateFields could break without
    // warning
    var objectCacheData = proxy.data && proxy.data.data;
    if (!objectCacheData) {
      throw new Error('`invalidateFields` is only known to work with apollo-cache-inmemory and the default `storeFactory`.');
    }
    matchFinder(objectCacheData, generator(proxy, result) || []).forEach(function (path) {
      return path.length === 1 && path[0] === ROOT ? Object.keys(objectCacheData[ROOT]).forEach(function (key) {
        return (0, _objectPath.del)(objectCacheData, [ROOT, key]);
      }) : (0, _objectPath.del)(objectCacheData, path);
    });
  };
};