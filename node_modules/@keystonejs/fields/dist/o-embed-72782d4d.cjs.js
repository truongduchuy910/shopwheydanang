'use strict';

function _interopDefault(ex) {
  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;
}

var _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty"));

require("@babel/runtime/helpers/objectWithoutProperties");

var pluralize = _interopDefault(require('pluralize'));

var core = require('@emotion/core');

var React = require('react');

var React__default = _interopDefault(React);

require("@babel/runtime/helpers/extends");

var button = require('@arch-ui/button');

var preview = require('./preview-0c33e771.cjs.js');

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

let type = 'oEmbed'; // TODO: Receive this value from the server somehow. 'pluralize' is a fairly
// large lib.

const path = pluralize.plural(type);
let Context = React.createContext(null);
let Provider = Context.Provider;

const Embed = _ref => {
  let {
    url,
    oembedData
  } = _ref;
  let options = React.useContext(Context);

  if (options.previewComponent) {
    // The adapter should implement this option
    const [Preview] = options.adminMeta.readViews([options.previewComponent]);
    return core.jsx(Preview, {
      url: url,
      options: options
    });
  } else {
    // This is a fallback so we can at least try to render _something_
    return core.jsx(preview.Preview, {
      data: oembedData,
      originalUrl: url
    });
  }
};

let Block = _ref2 => {
  let {
    url,
    oembedData,
    onChange,
    onRemove
  } = _ref2;
  let [currentValue, setCurrentValue] = React.useState(url);
  let embed = null;

  if (url) {
    embed = core.jsx(React.Suspense, {
      fallback: core.jsx("div", null, "Generating Preview...")
    }, core.jsx(Embed, {
      url: url,
      oembedData: oembedData
    }));
  }

  return core.jsx(React.Fragment, null, core.jsx("form", {
    onSubmit: e => {
      e.preventDefault();
      onChange(currentValue);
    }
  }, core.jsx("div", {
    css: {
      width: '100%',
      display: 'flex'
    }
  }, core.jsx("input", {
    type: "url",
    placeholder: "Enter a URL and press enter to add an embed",
    css: {
      flex: 10,
      display: 'inline',
      border: 'none',
      backgroundColor: 'transparent',
      outline: 'none',
      paddingTop: 8,
      paddingBottom: 8,
      fontSize: 18
    },
    onClick: e => {
      e.stopPropagation();
    },
    value: currentValue,
    onChange: e => {
      setCurrentValue(e.target.value);
    }
  }), core.jsx("div", {
    css: {
      display: 'inline-flex',
      alignItems: 'center',
      padding: 8
    }
  }, core.jsx(button.Button, {
    appearance: "danger",
    onClick: onRemove,
    type: "button"
  }, "Remove")))), embed);
};

function Sidebar(_ref3) {
  let {
    editor
  } = _ref3;
  return core.jsx("button", {
    type: "button",
    onClick: () => {
      editor.insertBlock({
        type
      });
    }
  }, "Embed");
}

function Node(_ref4) {
  let {
    node,
    editor
  } = _ref4;
  return core.jsx(Block, {
    url: node.data.get('url'),
    oembedData: node.data.get('oembedData'),
    onRemove: () => {
      editor.removeNodeByKey(node.key);
    },
    onChange: url => {
      editor.setNodeByKey(node.key, {
        data: node.data.set('url', url)
      });
    }
  });
}

let getSchema = () => ({
  isVoid: true
});

function serialize(_ref5) {
  let {
    node
  } = _ref5;
  const url = node.data.get('url');
  const joinIds = node.data.get('_joinIds');
  const mutations = joinIds && joinIds.length ? {
    connect: {
      id: joinIds[0]
    }
  } : {
    create: {
      embed: url
    }
  };
  return {
    mutations,
    node: _objectSpread({}, node.toJSON(), {
      // Zero out the data so we don't unnecesarily duplicate the url
      data: {}
    })
  };
}

function deserialize(_ref6) {
  let {
    node,
    joins
  } = _ref6;

  if (!joins || !Array.isArray(joins) || joins.length === 0 || !joins[0].embed) {
    console.error('No embed data received when rehydrating oEmbed block');
    return;
  } // Inject the original url back into the block


  return node.set('data', node.data.set('url', joins[0].embed.originalUrl).set('oembedData', joins[0].embed));
}

exports.Node = Node;
exports.Provider = Provider;
exports.Sidebar = Sidebar;
exports.deserialize = deserialize;
exports.getSchema = getSchema;
exports.path = path;
exports.serialize = serialize;
exports.type = type;
