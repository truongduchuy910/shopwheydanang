'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _taggedTemplateLiteral = _interopDefault(require('@babel/runtime/helpers/taggedTemplateLiteral'));
var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var _objectWithoutProperties = _interopDefault(require('@babel/runtime/helpers/objectWithoutProperties'));
var _defineProperty = _interopDefault(require('@babel/runtime/helpers/defineProperty'));
var apolloCacheInvalidation = require('@jesstelford/apollo-cache-invalidation');
var reactComponents = require('@apollo/react-components');
var hoistStatics = _interopDefault(require('hoist-non-react-statics'));
var mapValues = _interopDefault(require('lodash.mapvalues'));
var React = _interopDefault(require('react'));
var gql = _interopDefault(require('graphql-tag'));
var reactAdopt = require('react-adopt');
var memoizeOne = _interopDefault(require('memoize-one'));

function _templateObject() {
  const data = _taggedTemplateLiteral(["\n  query ListMeta {\n    _ksListsMeta {\n      schema {\n        type\n        queries\n        relatedFields {\n          type\n          fields\n        }\n      }\n    }\n  }\n"]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const flatten = arr => Array.prototype.concat(...arr);

const SchemaContext = React.createContext({});

const typeToRegex = type => new RegExp("^".concat(type, ":"));

const queriesToPath = queries => queries.map(query => [apolloCacheInvalidation.ROOT, new RegExp("^".concat(query))]); // Turns this
// [{ type: "Event", relatedFields: ["rsvps", "_rsvpsMeta"] }]
// Into this
// [[/^Event:/, /^rsvps/], [/^Event:/, /^_rsvpsMeta/]]


const relatedFieldsToPath = relatedFields => flatten(relatedFields.map(relatedField => (relatedField.fields || []).map(relatedPath => [typeToRegex(relatedField.type), new RegExp("^".concat(relatedPath))]))); // Gives us something like:
// {
//   RSVP: [[/^RSVP:/], [ROOT, /^_allRSVPsMeta/], [ROOT, /^allRSVPs/], [/^Event:/, /^_rsvpsMeta/]]
// }


const generateInvalidateionPaths = memoizeOne(keystoneTypes => keystoneTypes.reduce((memo, _ref) => {
  let {
    schema: {
      type,
      queries = [],
      relatedFields = []
    }
  } = _ref;
  memo[type] = [[typeToRegex(type)], ...queriesToPath(queries), ...relatedFieldsToPath(relatedFields)];
  return memo;
}, {})); // An Apollo post-mutation update function for invalidating entire types from
// the Apollo cache

const updater = (keystoneSchemaInfo, types) => {
  const cacheInvalidationFieldPaths = generateInvalidateionPaths(keystoneSchemaInfo);
  const paths = flatten((Array.isArray(types) ? types : [types]).map(type => cacheInvalidationFieldPaths[type]));
  return apolloCacheInvalidation.invalidateFields(() => paths);
};

class KeystoneApolloQueryCacheBuster extends React.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      data: null,
      dataSeen: false,
      refetching: false,
      loading: false,
      // 7? See https://www.apollographql.com/docs/react/api/react-apollo.html#graphql-query-data-networkStatus
      networkStatus: 7
    });
  }

  // When the cache is cleared within Apollo, it triggers a re-render of all the
  // watching `<Query>` components. However, it doesn't trigger a refetch of the
  // data, instead blindly trusting the cache data (which is now `undefined`).
  // So we have to do 3 things:
  // 1. Catch that case and manually trigger a refetch. Doing so then causes
  //    another re-render with an invalid loading state, so;
  // 2. we have to manually fix the `loading` and `networkState` values.
  // 3. Finally, during this refetch stage, we need to keep track of the
  //    previous set of data that was returned (so we don't return `undefined`,
  //    which normally never happens in Apollo).
  // The upside is when the cache is cleared, all existing components are
  // correctly re-rendered with expected loading states and data is correctly
  // refetched as expected.
  // The downside is there are a couple of extra re-renders triggered.
  static getDerivedStateFromProps(props, state) {
    const newState = {}; // These variables are derived from the props

    let loading = props.loading;
    let networkStatus = props.networkStatus; // These variables are persisted across re-renders and updated based on
    // props in this function

    let refetching = state.refetching;
    const cacheWasCleared = // It's only possible to clear the cache after data has successfully
    // loaded at least once
    state.dataSeen && // data === null is a valid value and doesn't indicate cache
    // clearing
    props.data !== null && ( // When cache is cleared, we get back either an empty object or undefined
    // depending on if it's an item that was cleared or a field on an item.
    // TODO: Pull the query names out of the `query` prop because a
    // query might have multiple, but only one was invalidated in the
    // cache
    !props.data || !Object.keys(props.data).length); // There's some legitimate data, so we're not refetching anymore

    if (refetching && !loading && !cacheWasCleared) {
      refetching = false;
      newState.refetching = refetching;
    } // When the cache is cleared, a re-render is triggered, but it
    // incorrectly re-renders the component as 'loading: true'.
    // The canonical Apollo <Query> component re-renders the component as
    // { loading: false, networkStatus: 4 }, so we emulate that here.


    if (refetching) {
      loading = true;
      networkStatus = 4;
    }

    if (!loading) {
      if (cacheWasCleared) {
        // We've received some data, but it's the result of the cache
        // being cleared, so we need to refetch
        refetching = true;
        newState.refetching = refetching;
        loading = true;
        networkStatus = 4; // TODO: Move to componentDidUpdate()?

        props.refetch();
      } else {
        // We've received some data that is ready to be rendered
        newState.dataSeen = true;
        newState.data = props.data;
      }
    }

    newState.loading = loading;
    newState.networkStatus = networkStatus;
    return newState;
  }

  render() {
    const _this$props = this.props,
          {
      children
    } = _this$props,
          props = _objectWithoutProperties(_this$props, ["children"]);

    return children(_objectSpread({}, props, {
      data: this.state.data,
      loading: this.state.loading,
      networkStatus: this.state.networkStatus
    }));
  }

} // A drop-in replacement for Apollo's `<Query>` component which works with the
// below KeystoneMutation component for clearing caches


const KeystoneQuery = (_ref2) => {
  let {
    children
  } = _ref2,
      props = _objectWithoutProperties(_ref2, ["children"]);

  return React.createElement(reactComponents.Query, props, renderProps => React.createElement(KeystoneApolloQueryCacheBuster, _extends({}, renderProps, {
    children: children
  })));
};

const wrapUpdateFunc = (keystoneSchemaInfo, invalidateTypes, update) => (proxy, data) => {
  if (invalidateTypes) {
    updater(keystoneSchemaInfo, invalidateTypes)(proxy, data);
  }

  return update(proxy, data);
}; // A mostly-drop-in replacement for Apollo's `<Mutation>` component with three
// changes:
// 1. An extra prop:
//   - invalidateTypes<String|Array<String>>: GraphQL types to invalidate upon
//     completion of this mutation. Setting this prop will guarantee all data
//     stored for that type in the Apollo cache is cleared. This is a middle
//     ground between every mutation manually updating cache values, and the
//     brute-force approach of clearing the entire Apollo cache.
//
// 2. Coallescing the render prop arguments to a single variable. ie, instead of
//
//    {(mutate, { data, loading, error, called, client }) => (
//      <button onClick={mutate}>Do it</button>
//    )}
//
//    It is now:
//
//    {(mutate) => {
//      const { data, loading, error, called, client } = mutate;
//      return <button onClick={mutate}>Do it</button>;
//    }}
//
// 3. Must be used within a tree wrapped in <KeystoneProvider> or withKeystone()


class KeystoneMutation extends React.Component {
  render() {
    const _this$props2 = this.props,
          {
      invalidateTypes,
      children,
      update: updateProp = () => {}
    } = _this$props2,
          props = _objectWithoutProperties(_this$props2, ["invalidateTypes", "children", "update"]);

    return React.createElement(SchemaContext.Consumer, null, keystoneSchemaInfo => {
      const interceptedUpdateProp = wrapUpdateFunc(keystoneSchemaInfo, invalidateTypes, updateProp);
      return React.createElement(reactComponents.Mutation, _extends({}, props, {
        update: interceptedUpdateProp
      }), (mutation, info) => {
        const interceptedMutation = (_ref3) => {
          let {
            // Support the same order of precedence that Apollo does (mutate({ update }) overwrites <Mutation update={}>)
            update: updateOption = updateProp,
            optimisticResponse
          } = _ref3,
              rest = _objectWithoutProperties(_ref3, ["update", "optimisticResponse"]);

          let interceptedUpdateOption;

          if (optimisticResponse) {
            let optimisticHandled = false;

            interceptedUpdateOption = function interceptedUpdateOption() {
              // We only want to clear the cache after the actual network call
              // has returned, not when we've set the optimistic response,
              // otherwise we can trigger a race condition where the refetch()
              // might return quicker than the mutation, resulting in stale
              // data. We might also trigger refetch() twice, which we want to
              // avoid.
              if (optimisticHandled) {
                return wrapUpdateFunc(keystoneSchemaInfo, invalidateTypes, updateOption)(...arguments);
              } else {
                optimisticHandled = true;
                return updateOption(...arguments);
              }
            };
          } else {
            // No optimistic response set? Always clear the cache when update is
            // called.
            interceptedUpdateOption = wrapUpdateFunc(keystoneSchemaInfo, invalidateTypes, updateOption);
          }

          return mutation(_objectSpread({
            update: interceptedUpdateOption,
            optimisticResponse
          }, rest));
        }; // Make sure all the mutation options are available on the mutation
        // function for consistency with the <Query> component
        // (ie; only single parameter required)


        const mergedMutation = Object.entries(info || {}).reduce((memo, _ref4) => {
          let [key, value] = _ref4;

          if (memo[key]) {
            return memo;
          }

          memo[key] = value;
          return memo;
        }, interceptedMutation);
        return children(mergedMutation, info);
      });
    });
  }

}

const META_QUERY = gql(_templateObject()); // These values are used in memoization functions, so we want to ensure it's
// always the same by defining it once here
// (ie; we don't create a new empty object on each call)

const emptyObject = Object.freeze(Object.create(null));
const emptyArray = []; // Will contain the result of the META_QUERY above (see note in KeystoneProvider
// for more info on when/why)

let keystoneListsMeta = [];

class KeystoneProvider extends React.Component {
  render() {
    return React.createElement(KeystoneQuery, {
      query: META_QUERY
    }, (_ref5) => {
      let {
        data,
        loading
      } = _ref5;
      // NOTE: We're setting a global variable here, which then impacts the
      // functionality of local resolvers.
      // This is hacky, but there is no other way to get the data into the
      // right place at the right time given the chicken and egg situation
      // we have:
      // Chicken: Setting up Apollo with the 'link-state' adapter to set the
      //   _isOptimistic flag.
      // Egg: We need to know the types to set the flag on, but that comes
      //   via a GraphQL query from Apollo).
      keystoneListsMeta = loading || !data ? emptyArray : data._ksListsMeta || emptyArray;
      return React.createElement(SchemaContext.Provider, {
        value: keystoneListsMeta
      }, this.props.children);
    });
  }

} // A HOC version of <KeystoneProvider>


const withKeystone = Component => {
  const WrappingComponent = props => React.createElement(KeystoneProvider, null, React.createElement(Component, props));

  WrappingComponent.displayName = "WithKeystone(".concat(Component.displayName || Component.name, ")");
  hoistStatics(WrappingComponent, Component);
  return WrappingComponent;
}; // To keep track of optimistic responses correctly, we inject an `_isOptimistic`
// flag for every item in the Apollo cache.
// To do so, we wrap the `resolvers` option of an Apollo-Link-State instance.


function injectIsOptimisticFlag() {
  let _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyObject;

  let {
    resolvers: _resolvers = emptyObject,
    defaults = emptyObject
  } = _ref6,
      rest = _objectWithoutProperties(_ref6, ["resolvers", "defaults"]);

  const injectIsOptimisticFlagToKeystoneTypes = memoizeOne((inputResolvers, keystoneTypes) => (keystoneTypes || []).reduce((memo, _ref7) => {
    let {
      schema: {
        type
      }
    } = _ref7;
    return _objectSpread({}, memo, {
      [type]: _objectSpread({}, memo[type], {
        // Inject the _isOptimistic field resolver here.
        // We do this to ensure that every type can access a boolean value.
        _isOptimistic: (rootValue, args, _ref8) => {
          let {
            optimisticResponse
          } = _ref8;
          // We only care if it is or isn't an optimistic response, not what the
          // actual response is or not.
          // The existence of this key indicates it is an optimistic response.
          return !!optimisticResponse;
        }
      })
    });
  }, inputResolvers));
  return _objectSpread({
    // Return a function which performs a memoized lookup based on the current
    // known state of resolvers / list info
    resolvers: () => injectIsOptimisticFlagToKeystoneTypes(_resolvers, keystoneListsMeta),
    defaults: _objectSpread({}, defaults, {
      _isOptimistic: false
    })
  }, rest);
} // Flatten your nested <Query>/<Mutation>s to make your code easier to read and
// reason about.
// Go from this:

/*
const GET_FOO_QUERY = gql`...`
const UPDATE_FOO_MUTATION = gql`...`
const ADD_FOO_MUTATION = gql`...`

const App = () => (
  <Query query={GET_FOO_QUERY}>
    {({ data }) => (
      <Mutation query={UPDATE_FOO_MUTATION}>
        {updateFoo => (
          <Mutation query={ADD_FOO_MUTATION}>
            {addFoo => (
              <div>
                Foo: <pre>{JSON.stringify(data, null, 2)}</pre>
                <button onClick={updateFoo}>Update</button>
                <button onClick={addFoo}>Add</button>
              </div>
            )}
          </Mutation>
        )}
      </Mutation>
    )}
  </Query>
)
*/
//
// To this:
//

/*
const GET_FOO_QUERY = gql`...`
const UPDATE_FOO_MUTATION = gql`...`
const ADD_FOO_MUTATION = gql`...`

// NOTE: This format only works with the `Query`/`Mutation` components from this
// module, not Apollo's `Query`/`Mutation` queries. For those, you'll have to
// wrap each item in a function ({ render }) => <Query ..>{render}</Query>
const GraphQL = flattenApollo({
  foo: <Query query={GET_FOO_QUERY}>,
  updateFoo: <Mutation query={UPDATE_FOO_MUTATION}>,
  addFoo: <Mutation query={ADD_FOO_MUTATION}>,
})

const App = () => (
  <GraphQL>
    {({ foo, updateFoo, addFoo }) => (
      <div>
        Foo: <pre>{JSON.stringify(foo, null, 2)}</pre>
        <button onClick={updateFoo}>Update</button>
        <button onClick={addFoo}>Add</button>
      </div>
    )}
  </GraphQL>
);
*/


const flattenApollo = options => reactAdopt.adopt(mapValues(options, adoption => {
  if (typeof adoption === 'function') {
    return adoption;
  }

  return (_ref9) => {
    let {
      render
    } = _ref9,
        props = _objectWithoutProperties(_ref9, ["render"]);

    return React.cloneElement(adoption, props, render);
  };
}));

exports.KeystoneProvider = KeystoneProvider;
exports.Mutation = KeystoneMutation;
exports.Query = KeystoneQuery;
exports.flattenApollo = flattenApollo;
exports.injectIsOptimisticFlag = injectIsOptimisticFlag;
exports.withKeystone = withKeystone;
