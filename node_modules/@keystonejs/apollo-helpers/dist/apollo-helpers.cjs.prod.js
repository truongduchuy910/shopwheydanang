"use strict";

function _interopDefault(ex) {
  return ex && "object" == typeof ex && "default" in ex ? ex.default : ex;
}

Object.defineProperty(exports, "__esModule", {
  value: !0
});

var _taggedTemplateLiteral = _interopDefault(require("@babel/runtime/helpers/taggedTemplateLiteral")), _extends = _interopDefault(require("@babel/runtime/helpers/extends")), _objectWithoutProperties = _interopDefault(require("@babel/runtime/helpers/objectWithoutProperties")), _defineProperty = _interopDefault(require("@babel/runtime/helpers/defineProperty")), apolloCacheInvalidation = require("@jesstelford/apollo-cache-invalidation"), reactComponents = require("@apollo/react-components"), hoistStatics = _interopDefault(require("hoist-non-react-statics")), mapValues = _interopDefault(require("lodash.mapvalues")), React = _interopDefault(require("react")), gql = _interopDefault(require("graphql-tag")), reactAdopt = require("react-adopt"), memoizeOne = _interopDefault(require("memoize-one"));

function _templateObject() {
  const data = _taggedTemplateLiteral([ "\n  query ListMeta {\n    _ksListsMeta {\n      schema {\n        type\n        queries\n        relatedFields {\n          type\n          fields\n        }\n      }\n    }\n  }\n" ]);
  return _templateObject = function() {
    return data;
  }, data;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter((function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    }))), keys.push.apply(keys, symbols);
  }
  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach((function(key) {
      _defineProperty(target, key, source[key]);
    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach((function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    }));
  }
  return target;
}

const flatten = arr => Array.prototype.concat(...arr), SchemaContext = React.createContext({}), typeToRegex = type => new RegExp("^".concat(type, ":")), queriesToPath = queries => queries.map(query => [ apolloCacheInvalidation.ROOT, new RegExp("^".concat(query)) ]), relatedFieldsToPath = relatedFields => flatten(relatedFields.map(relatedField => (relatedField.fields || []).map(relatedPath => [ typeToRegex(relatedField.type), new RegExp("^".concat(relatedPath)) ]))), generateInvalidateionPaths = memoizeOne(keystoneTypes => keystoneTypes.reduce((memo, _ref) => {
  let {schema: {type: type, queries: queries = [], relatedFields: relatedFields = []}} = _ref;
  return memo[type] = [ [ typeToRegex(type) ], ...queriesToPath(queries), ...relatedFieldsToPath(relatedFields) ], 
  memo;
}, {})), updater = (keystoneSchemaInfo, types) => {
  const cacheInvalidationFieldPaths = generateInvalidateionPaths(keystoneSchemaInfo), paths = flatten((Array.isArray(types) ? types : [ types ]).map(type => cacheInvalidationFieldPaths[type]));
  return apolloCacheInvalidation.invalidateFields(() => paths);
};

class KeystoneApolloQueryCacheBuster extends React.Component {
  constructor() {
    super(...arguments), _defineProperty(this, "state", {
      data: null,
      dataSeen: !1,
      refetching: !1,
      loading: !1,
      networkStatus: 7
    });
  }
  static getDerivedStateFromProps(props, state) {
    const newState = {};
    let loading = props.loading, networkStatus = props.networkStatus, refetching = state.refetching;
    const cacheWasCleared = state.dataSeen && null !== props.data && (!props.data || !Object.keys(props.data).length);
    return !refetching || loading || cacheWasCleared || (refetching = !1, newState.refetching = refetching), 
    refetching && (loading = !0, networkStatus = 4), loading || (cacheWasCleared ? (refetching = !0, 
    newState.refetching = refetching, loading = !0, networkStatus = 4, props.refetch()) : (newState.dataSeen = !0, 
    newState.data = props.data)), newState.loading = loading, newState.networkStatus = networkStatus, 
    newState;
  }
  render() {
    const _this$props = this.props, {children: children} = _this$props;
    return children(_objectSpread({}, _objectWithoutProperties(_this$props, [ "children" ]), {
      data: this.state.data,
      loading: this.state.loading,
      networkStatus: this.state.networkStatus
    }));
  }
}

const KeystoneQuery = _ref2 => {
  let {children: children} = _ref2, props = _objectWithoutProperties(_ref2, [ "children" ]);
  return React.createElement(reactComponents.Query, props, renderProps => React.createElement(KeystoneApolloQueryCacheBuster, _extends({}, renderProps, {
    children: children
  })));
}, wrapUpdateFunc = (keystoneSchemaInfo, invalidateTypes, update) => (proxy, data) => (invalidateTypes && updater(keystoneSchemaInfo, invalidateTypes)(proxy, data), 
update(proxy, data));

class KeystoneMutation extends React.Component {
  render() {
    const _this$props2 = this.props, {invalidateTypes: invalidateTypes, children: children, update: updateProp = (() => {})} = _this$props2, props = _objectWithoutProperties(_this$props2, [ "invalidateTypes", "children", "update" ]);
    return React.createElement(SchemaContext.Consumer, null, keystoneSchemaInfo => {
      const interceptedUpdateProp = wrapUpdateFunc(keystoneSchemaInfo, invalidateTypes, updateProp);
      return React.createElement(reactComponents.Mutation, _extends({}, props, {
        update: interceptedUpdateProp
      }), (mutation, info) => {
        const mergedMutation = Object.entries(info || {}).reduce((memo, _ref4) => {
          let [key, value] = _ref4;
          return memo[key] ? memo : (memo[key] = value, memo);
        }, _ref3 => {
          let interceptedUpdateOption, {update: updateOption = updateProp, optimisticResponse: optimisticResponse} = _ref3, rest = _objectWithoutProperties(_ref3, [ "update", "optimisticResponse" ]);
          if (optimisticResponse) {
            let optimisticHandled = !1;
            interceptedUpdateOption = function() {
              return optimisticHandled ? wrapUpdateFunc(keystoneSchemaInfo, invalidateTypes, updateOption)(...arguments) : (optimisticHandled = !0, 
              updateOption(...arguments));
            };
          } else interceptedUpdateOption = wrapUpdateFunc(keystoneSchemaInfo, invalidateTypes, updateOption);
          return mutation(_objectSpread({
            update: interceptedUpdateOption,
            optimisticResponse: optimisticResponse
          }, rest));
        });
        return children(mergedMutation, info);
      });
    });
  }
}

const META_QUERY = gql(_templateObject()), emptyObject = Object.freeze(Object.create(null)), emptyArray = [];

let keystoneListsMeta = [];

class KeystoneProvider extends React.Component {
  render() {
    return React.createElement(KeystoneQuery, {
      query: META_QUERY
    }, _ref5 => {
      let {data: data, loading: loading} = _ref5;
      return keystoneListsMeta = loading || !data ? emptyArray : data._ksListsMeta || emptyArray, 
      React.createElement(SchemaContext.Provider, {
        value: keystoneListsMeta
      }, this.props.children);
    });
  }
}

const withKeystone = Component => {
  const WrappingComponent = props => React.createElement(KeystoneProvider, null, React.createElement(Component, props));
  return WrappingComponent.displayName = "WithKeystone(".concat(Component.displayName || Component.name, ")"), 
  hoistStatics(WrappingComponent, Component), WrappingComponent;
};

function injectIsOptimisticFlag() {
  let _ref6 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : emptyObject, {resolvers: _resolvers = emptyObject, defaults: defaults = emptyObject} = _ref6, rest = _objectWithoutProperties(_ref6, [ "resolvers", "defaults" ]);
  const injectIsOptimisticFlagToKeystoneTypes = memoizeOne((inputResolvers, keystoneTypes) => (keystoneTypes || []).reduce((memo, _ref7) => {
    let {schema: {type: type}} = _ref7;
    return _objectSpread({}, memo, {
      [type]: _objectSpread({}, memo[type], {
        _isOptimistic: (rootValue, args, _ref8) => {
          let {optimisticResponse: optimisticResponse} = _ref8;
          return !!optimisticResponse;
        }
      })
    });
  }, inputResolvers));
  return _objectSpread({
    resolvers: () => injectIsOptimisticFlagToKeystoneTypes(_resolvers, keystoneListsMeta),
    defaults: _objectSpread({}, defaults, {
      _isOptimistic: !1
    })
  }, rest);
}

const flattenApollo = options => reactAdopt.adopt(mapValues(options, adoption => "function" == typeof adoption ? adoption : _ref9 => {
  let {render: render} = _ref9, props = _objectWithoutProperties(_ref9, [ "render" ]);
  return React.cloneElement(adoption, props, render);
}));

exports.KeystoneProvider = KeystoneProvider, exports.Mutation = KeystoneMutation, 
exports.Query = KeystoneQuery, exports.flattenApollo = flattenApollo, exports.injectIsOptimisticFlag = injectIsOptimisticFlag, 
exports.withKeystone = withKeystone;
